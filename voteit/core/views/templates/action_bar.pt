<ul class="action_bar" i18n:domain="voteit.core">

    <li class="menuitem" tal:condition="context_has_permission('Edit', context)">
    	<a class="buttonize"
		   tal:attributes="href api.resource_url(context, request) + '@@edit'"
		   i18n:translate="">Edit</a>
	</li>
    <li class="menuitem" tal:condition="context_has_permission('Delete', context)">
    	<a class="buttonize"
		   tal:attributes="href api.resource_url(context, request) + '@@delete'"
		   i18n:translate="">Delete</a>
	</li>

    <tal:poll condition="context.content_type == 'Poll'" tal:define="has_voted api.userid and api.userid in context">
    	<tal:comment condition="False">
    		Poll controls - note that these are ment for a poll as a context, so while the edit button above
			will be visible if a this view is invoked directly on a vote, the "Change vote" button won't be visible.
    	</tal:comment>
        <li class="menuitem"
            tal:condition="has_voted and context_has_permission('Add Vote', context)">
            <a class="buttonize"
			   tal:attributes="href api.resource_url(context, request) + api.userid + '/@@edit'"
			   i18n:translate="">Change vote</a>
        </li>
        <li class="menuitem"
            tal:condition="has_voted and context_has_permission('Add Vote', context)">
            <a class="buttonize"
			   tal:attributes="href api.resource_url(context, request) + api.userid + '/@@delete'"
			   i18n:translate="">Delete vote</a>
        </li>
        <li class="menuitem"
            tal:condition="context.get_workflow_state() == 'closed'">
            <a class="buttonize"
			   tal:attributes="href api.resource_url(context, request) + '@@poll_raw_data'"
			   i18n:translate="">Poll raw data</a>
        </li>
	</tal:poll>
	
	<tal:meeting condition="context.content_type == 'Meeting'">
        <tal:comment condition="False">
            Common functions for meeting.
        </tal:comment>
        <li class="dropdown_menu menuitem">
            <a class="buttonize"
			   tal:attributes="href api.resource_url(context, request) + '@@participants'"
			   i18n:translate="">Participants</a>
        </li>
	</tal:meeting>
	
	<tal:users_only condition="not is_moderator">
		<tal:comment condition="False">
			Users only actions. This is to avoid cluttering the administrative interface
			with actions that might exist somewhere else. (Like workflows)
			
			Note that repoze.workflow checks permissions through request.context, so checking
			available workflow transitions the normal way won't work.
		</tal:comment>
		<tal:retract condition="show_retract()">
		    <li class="menuitem">
	            <a class="buttonize confirm-retract"
				   tal:attributes="href api.resource_url(context, request) + '@@state?state=retracted'"
				   i18n:translate="">Retract</a>
		    </li>
		</tal:retract>
	</tal:users_only>

    <tal:admin>
        <li tal:condition="context.content_type == 'SiteRoot' and
                           context_has_permission('Manage Server', context)"
            class="dropdown_menu menuitem">
            <a class="buttonize"
			   tal:attributes="href api.resource_url(context, request) + '@@logs'"
			   i18n:translate="">Server logs</a>
        </li>
	</tal:admin>
	
	<tal:moderator condition="is_moderator">
		<tal:comment condition="False">
			Moderator only actions. Avoid rendering these for all other users.
			It's okay to place more computationally expensive things here.
		</tal:comment>
        <li tal:condition="context.content_type == 'Poll' and
		                   context_has_permission('Edit', context) and
						   context.get_poll_plugin().get_settings_schema()|False"
		    class="menuitem">
            <a class="buttonize"
			   tal:attributes="href api.resource_url(context, request) + '@@poll_config'"
			   i18n:translate="">Poll settings</a>
        </li>
        <li tal:condition="context.content_type == 'Meeting' and
                           context.get_workflow_state() != 'private'"
            class="menuitem">
            <a class="buttonize"
			   tal:attributes="href api.resource_url(context, request) + '@@add_tickets'"
			   i18n:translate="">Invite participants</a>
        </li>
        <li tal:condition="context.content_type == 'Meeting' and
                           context.get_workflow_state() != 'private'"
            class="menuitem">
            <a class="buttonize"
			   tal:attributes="href api.resource_url(context, request) + '@@manage_tickets'"
			   i18n:translate="">Manage invites</a>
        </li>
             
        <li tal:condition="(context.content_type == 'SiteRoot' or context.content_type == 'Meeting' or context.content_type == 'AgendaItem') and
                           api.addable_types|False" class="dropdown_menu menuitem">
        	<a href="#" class="buttonize menu_header"><span i18n:translate="">Content</span> &raquo;</a>
            <ul class="menu_body">
            <tal:iterate tal:repeat="type_name api.addable_types">
                <li><a tal:attributes="href string:@@add?content_type=$type_name">
                    <span i18n:translate="">Add</span>
					<span tal:replace="type_name">somestuff</span>
                </a></li>
            </tal:iterate>
            </ul>
        </li>

	    <li tal:condition="states|False" class="dropdown_menu menuitem">
			<a href="#"
			   class="buttonize menu_header">
			   	<span i18n:translate="">Set state</span> &raquo;</a>
			<ul class="menu_body">
				<tal:iterate repeat="state states">
				<li tal:attributes="class state.current and 'current'">
					<a class="confirm-state" tal:attributes="href api.resource_url(context, request) + '@@state' + '?state=' + state.name"
					   tal:content="api.translate(state.title)">State</a>
				</li>
				</tal:iterate>
			</ul>
	    </li>
	</tal:moderator>

</ul>
