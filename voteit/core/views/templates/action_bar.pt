<ul class="action_bar">

    <li class="menuitem" tal:condition="context_has_permission('Edit', context)">
    	<a class="buttonize" tal:attributes="href api.resource_url(context, request) + '@@edit'">Edit</a>
	</li>
    <li class="menuitem" tal:condition="context_has_permission('Delete', context)">
    	<a class="buttonize"  tal:attributes="href api.resource_url(context, request) + '@@delete'">Delete</a>
	</li>

    <tal:poll condition="context.content_type == 'Poll'" tal:define="has_voted api.userid and api.userid in context">
    	<tal:comment condition="False">
    		Poll controls - note that these are ment for a poll as a context, so while the edit button above
			will be visible if a this view is invoked directly on a vote, the "Change vote" button won't be visible.
    	</tal:comment>
	    <li class="menuitem"
		    tal:condition="not has_voted and context_has_permission('Add Vote', context)">
	        <a class="buttonize" tal:attributes="href api.resource_url(context, request) + '@@vote'">Vote</a>
	    </li>
        <li class="menuitem"
            tal:condition="has_voted and context_has_permission('Add Vote', context)">
            <a class="buttonize" tal:attributes="href api.resource_url(context, request) + api.userid + '/@@edit'">Change vote</a>
        </li>
        <li class="menuitem"
            tal:condition="has_voted">
            <a class="buttonize" tal:attributes="href api.resource_url(context, request) + api.userid">Your vote</a>
        </li>
        <li class="menuitem"
            tal:condition="context.get_workflow_state() == 'closed'">
            <a class="buttonize" tal:attributes="href api.resource_url(context, request) + '@@poll_raw_data'">Poll raw data</a>
        </li>
	</tal:poll>
	
	<tal:meeting condition="context.content_type == 'Meeting'">
        <tal:comment condition="False">
            Common functions for meeting.
        </tal:comment>
        <li class="menuitem">
            <a class="buttonize" tal:attributes="href api.resource_url(context, request) + '@@meeting_access'">Participants</a>
        </li>
	</tal:meeting>
	
	<tal:users_only condition="not is_moderator">
		<tal:comment condition="False">
			Users only actions. This is to avoid cluttering the administrative interface
			with actions that might exist somewhere else. (Like workflows)
			
			Note that repoze.workflow checks permissions through request.context, so checking
			available workflow transitions the normal way won't work.
		</tal:comment>
		<tal:retract condition="show_retract()">
		    <li class="menuitem">
	            <a class="buttonize"
				   tal:attributes="href api.resource_url(context, request) + '@@state?state=retracted'">Retract</a>
		    </li>
		</tal:retract>
	</tal:users_only>

    <tal:admin>
		<li tal:condition="context.content_type in ['Meeting', 'SiteRoot'] and
		                   context_has_permission('Manage Groups', context)"
			class="dropdown_menu menuitem">
	        <a class="buttonize" tal:attributes="href api.resource_url(context, request) + '@@edit_groups'">Permissions</a>
		</li>
	</tal:admin>
	
	<tal:moderator condition="is_moderator">
		<tal:comment condition="False">
			Moderator only actions. Avoid rendering these for all other users.
			It's okay to place more computationally expensive things here.
		</tal:comment>
        <li tal:condition="context.content_type == 'Poll' and
		                   context_has_permission('Edit', context) and
						   context.get_poll_plugin().get_settings_schema()|False"
		    class="menuitem">
            <a class="buttonize" tal:attributes="href api.resource_url(context, request) + '@@poll_config'">Poll settings</a>
        </li>
        <li tal:condition="context.content_type == 'Meeting' and
                           context.get_workflow_state() != 'private'"
            class="menuitem">
            <a class="buttonize" tal:attributes="href api.resource_url(context, request) + '@@add_tickets'">Invite participants</a>
        </li>
        <li tal:condition="context.content_type == 'Meeting' and
                           context.get_workflow_state() != 'private'"
            class="menuitem">
            <a class="buttonize" tal:attributes="href api.resource_url(context, request) + '@@manage_tickets'">Manage invites</a>
        </li>
             
        <li tal:condition="api.addable_types|False" class="dropdown_menu menuitem">
        	<a href="#" class="buttonize menu_header">Content &raquo;</a>
            <ul class="menu_body">
            <tal:iterate tal:repeat="type_name api.addable_types">
                <li><a tal:content="string: add $type_name"
                   tal:attributes="href string:@@add?content_type=$type_name">Name</a></li>
            </tal:iterate>
            </ul>
        </li>

	    <li tal:condition="states|False" class="dropdown_menu menuitem">
			<a href="#" class="buttonize menu_header">Set state &raquo;</a>
			<ul class="menu_body">
				<tal:iterate repeat="state states">
				<li tal:attributes="class state.current and 'current'">
					<a tal:attributes="href api.resource_url(context, request) + '@@state' + '?state=' + state.name"
					   tal:content="state.title">State</a>
				</li>
				</tal:iterate>
			</ul>
	    </li>
	</tal:moderator>
	<!-- FIXME: this is just a dummy for showing the feature -->
    <a tal:attributes="href string:/help/${api.locale}/dummy.html" target="_blank" class="help">?</a>
</ul>

